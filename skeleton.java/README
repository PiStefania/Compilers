Εργασία Μεταγλωττιστών
Μέρος 1ο 

Στην εργασία αυτή κληθήκαμε να υλοποιήσουμε τον λεκτικό και συντακτικό αναλυτή για τη γλώσσα Grace. Επιλέξαμε τη γλώσσα Java και για την εκτέλεση του προγράμματος επιλέξαμε παραγωγή Java bytecode και διερμηνεία αυτού στη JavaVM. Το εργαλείο που χρησιμοποιήσαμε είναι το SableCC.
Στο αρχείο «parser.grammar» δημιουργήσαμε helpers, tokens, ignored tokens και productions. Σε ένα αρχείο «Printer.java» υλοποιήσαμε μια κλάση Printer και τις συναρτήσεις της, με τις οποίες εκτυπώσαμε και το CST  που δημιουργήθηκε. Εκτυπώσαμε τα δεδομένα που ανήκουν σε ένα node το οποίο παράγεται από τα productions επιλεκτικά. Για παράδειγμα στη συνάρτηση inAProgram  εκτυπώνεται μόνο η λέξη Program μαζί με μια αριστερή παρένθεση ‘(‘ , ενώ στην outAProgram εκτυπώνεται η δεξιά παρένθεση ‘)‘. Αυτό, καθώς και η προσθήκη κενών ‘ ‘  (indentation) αποσκοπεί στην καλύτερη κατανόηση των ορίων του κάθε κόμβου. Στη συνάρτηση main, καλείται η κλάση Printer, για την εκτύπωση του δέντρου.
  
Σχόλια

• Δεν εμφανίζουμε ονομασίες ορισμένων τύπων κόμβων, καθώς τις θεωρούμε αυτονόητες (π.χ το DataType υπάρχει σχολιασμένο στις συναρτήσεις που αφορούν τους DataType κόμβους, αφού μπορεί να εκτυπώνεται το «Type»). 

Μεταγλώττιση της εργασίας

• Για τη μεταγλώττιση της εργασίας, χρησιμοποιήσαμε το εργαλείο maven που παρέχεται από το πρόγραμμα IntelliJ IDEA.
• Κάνουμε import,  από το φάκελο Skeleton.java,  το αρχείο pom.xml.
• Μεταγλωττίζουμε το πρόγραμμα με τις επιλογές clean (διαγραφή generated  αρχείων) και compile (build -> δημιουργία generated  αρχείων) του προγράμματος IntelliJ IDEA από το παράθυρο Maven Projects.


Εκτέλεση Αρχείου

• Επιλέγουμε την Main.java ως προεπιλεγμένη main του project μας.
• Για την εκτέλεση αρχείου απαιτείται η εισαγωγή κάποιου προγράμματος είτε με System.in είτε με ολοκληρωμένο path.


Εκτέλεση Παραδειγμάτων

Hello World
([Program]
 ([Function Definition]
  ([Header] fun [id] hello ( ) : ([Return Data Type] nothing ))

  ([Block] 
   { 
    ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [Constant String]: "Hello world!\n" ) ) ) ); )

   } 
  )
 )
)


Reverse
([Program]
 ([Function Definition]
  ([Header] fun [id] main ( ) : ([Return Data Type] nothing ))
  ([Local Definition]
   ([Variable Definition] var [id] r : ([Type] char[32] ); )
  )
  ([Local Definition]
   ([Function Definition]
    ([Header] fun [id] reverse ( ([Function Parameters Definition] ref [id] s : [Function Parameter Type] char[] ))) : ([Return Data Type] nothing ))
    ([Local Definition]
     ([Variable Definition] var [id] i , [id] l : ([Type] int )); )
    )

    ([Block] 
     { 
      ([Statement] ([L-Value] [id] l ) [Assignment] <- ([Expression] ([Function Call][id] strlen ( ([Expression] ([L-Value] [id] s ) ) ) )) ; )
      ([Statement] ([L-Value] [id] i ) [Assignment] <- ([Expression] [Constant]: 0 ) ; )
      ([Statement] while ([Expression] ([L-Value] [id] i ) ) [Smaller] < ([Expression] ([L-Value] [id] l ) ) do 
       ([Statement] 
        ([Block] 
         { 
          ([Statement] ([L-Value] ([L-Value] [id] r ) [ ([Expression] ([L-Value] [id] i ) ) ] ) [Assignment] <- ([Expression] ([L-Value] ([L-Value] [id] s ) [ ([Expression] ((([L-Value] [id] l ) [Minus] - ([L-Value] [id] i ) )[Minus] - [Constant]: 1 )) ] ) ) ; )
          ([Statement] ([L-Value] [id] i ) [Assignment] <- ([Expression] (([L-Value] [id] i ) [Plus] + [Constant]: 1 )) ; )

         } 
        )
       )
      )
      ([Statement] ([L-Value] ([L-Value] [id] r ) [ ([Expression] ([L-Value] [id] i ) ) ] ) [Assignment] <- ([Expression] [Constant character]: '\0' ) ; )

     } 
    )
   )
  )

  ([Block] 
   { 
    ([Statement] ([Function Call][id] reverse ( ([Expression] ([L-Value] [Constant String]: "\n!dlrow olleH" ) ) ) ); )
    ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [id] r ) ) ) ); )

   } 
  )
 )
)


Hanoi
([Program]
 ([Function Definition]
  ([Header] fun [id] solve ( ) : ([Return Data Type] nothing ))
  ([Local Definition]
   ([Function Definition]
    ([Header] fun [id] hanoi ( ([Function Parameters Definition] [id] rings : ([Function Parameter Type] int ))); ([Function Parameters Definition] ref [id] source , [id] target , [id] auxiliary : [Function Parameter Type] char[] ))) : ([Return Data Type] nothing ))
    ([Local Definition]
     ([Function Definition]
      ([Header] fun [id] move ( ([Function Parameters Definition] ref [id] source , [id] target : [Function Parameter Type] char[] ))) : ([Return Data Type] nothing ))

      ([Block] 
       { 
        ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [Constant String]: "Moving from " ) ) ) ); )
        ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [id] source ) ) ) ); )
        ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [Constant String]: " to " ) ) ) ); )
        ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [id] target ) ) ) ); )
        ([Statement] ([Function Call][id] puts ( ([Expression] ([L-Value] [Constant String]: ".\n" ) ) ) ); )

       } 
      )
     )
    )

    ([Block] 
     { 
      ([Statement] if ([Expression] ([L-Value] [id] rings ) ) [Greater or Equal] >= ([Expression] [Constant]: 1 ) then 
       ([Statement] 
        ([Block] 
         { 
          ([Statement] ([Function Call][id] hanoi ( ([Expression] (([L-Value] [id] rings ) [Minus] - [Constant]: 1 )) , ([Expression] ([L-Value] [id] source ) ) , ([Expression] ([L-Value] [id] auxiliary ) ) , ([Expression] ([L-Value] [id] target ) ) ) ); )
          ([Statement] ([Function Call][id] move ( ([Expression] ([L-Value] [id] source ) ) , ([Expression] ([L-Value] [id] target ) ) ) ); )
          ([Statement] ([Function Call][id] hanoi ( ([Expression] (([L-Value] [id] rings ) [Minus] - [Constant]: 1 )) , ([Expression] ([L-Value] [id] auxiliary ) ) , ([Expression] ([L-Value] [id] target ) ) , ([Expression] ([L-Value] [id] source ) ) ) ); )

         } 
        )
       )
      )

     } 
    )
   )
  )
  ([Local Definition]
   ([Variable Definition] var [id] NumberOfRings : ([Type] int )); )
  )

  ([Block] 
   { 
    ([Statement] ([Function Call][id] writeString ( ([Expression] ([L-Value] [Constant String]: "Rings: " ) ) ) ); )
    ([Statement] ([L-Value] [id] NumberOfRings ) [Assignment] <- ([Expression] ([Function Call][id] geti ( ) ) )) ; )
    ([Statement] ([Function Call][id] hanoi ( ([Expression] ([L-Value] [id] NumberOfRings ) ) , ([Expression] ([L-Value] [Constant String]: "left" ) ) , ([Expression] ([L-Value] [Constant String]: "right" ) ) , ([Expression] ([L-Value] [Constant String]: "middle" ) ) ) ); )

   } 
  )
 )
)


Μέρος 2ο

Στην εργασία αυτή κληθήκαμε να ολοκληρώσουμε την σημασιολογική ανάλυση και τον ενδιάμεσο κώδικα για τη γλώσσα Grace. Αρχικά, δημιουργήσαμε το δέντρο AST, χρησιμοποιώντας τα productions από το πρώτο μέρος.
Επιλέξαμε τους κόμβους που μας χρειάστηκαν για τον σημασιολογικό έλεγχο με βάση την σωστή σύνταξη AST. Στην συνέχεια, μέσα στους In και Out κόμβους που δημιουργήθηκαν, υλοποίησαμε τον σημασιολογικό έλεγχο αλλά και τον ενδιάμεσο κώδικα.

Για την σημασιολογική ανάλυση, δημιουργήσαμε την κλάση SymbolTable.java η οποία έχει τις παρακάτω λειτουργίες (περιλαμβάνονται μόνο αυτές που χρησιμοποιούνται):

• Εκτύπωση κεντρικής στοίβας με την συνάρτηση : print
• Δημιουργία νέας εμβέλειας και εισαγωγή αντικειμένου με την συνάρτηση : enter
• Εισαγωγή αντικειμένου στην ίδια εμβέλεια με την συνάρτηση : insert
• Αναζήτηση αντεικειμένου με παράμετρο το όνομά του στην ίδια εμβέλεια με την συνάρτηση : lookupVar
• Αναζήτηση παραμέτρων σε δήλωση συνάρτησης με την συνάρτηση : lookupPar
• Αναζήτηση δήλωσης και κλήσης συνάρτησης με την συνάρτηση : lookupDecl
• Αναζήτηση ίδιας συνάρτησης στην στοίβα με την συνάρτηση : lookupFunc
• Αναζήτηση ίδιας συνάρτησης ή μεταβλητής σε όλη την στοίβα με την συνάρτηση : lookupVarAndFunc
• Αναζήτηση μεταβλητής με ίδιο όνομα και διαφορετικό τύπο στην στοίβα με την συνάρτηση : lookupVarAndType
• Αναζήτηση τύπου μεταβλητής στην στοίβα με την συνάρτηση : FindVariableType
• Αναζήτηση μεταβλητής στην στοίβα έτσι ώστε να επιστρέψουμε την θέση του σε αυτήν με την συνάρτηση : FindVarPosition
• Αναζήτηση δήλωσης συνάρτησης ώστε έτσι οι παράμετροι να αλλάξουν από "par" σε "par_decl" με την συνάρτηση : findDecl
• Διαγραφή εμβελειών με την συνάρτηση : exit
• Εισαγωγή αντικειμένου στην στοίβα συναρτήσεων με την συνάρτηση : insertFuncStack
• Εκτύπωση στοίβας που περιλαμβάνει τις συναρτήσεις με την συνάρτηση : printFuncStack
• Έλεγχος εμβέλειας και ονόματος μίας κλήσης συνάρτησης χωρίς παραμέτρους με την συνάρτηση : checkScopeWithout
• Έλεγχος εμβέλειας και ονόματος και αριθμού παραμέτρων μίας κλήσης συνάρτησης με παραμέτρους με την συνάρτηση : checkScopeWith
• Έλεγχος αν μία έκφραση είναι αριθμός με την συνάρτηση : isNumeric
• Επιστροφή τύπου μίας συνάρτησης από την στοίβα συναρτήσεων με την συνάρτηση : getFuncType
• Διαγραφή στοίβας συναρτήσεων με την συνάρτηση : deleteFuncStack
• Εισαγωγή στο Dictionary με τις παραμέτρους τύπου ref με την συνάρτηση : insertRefList

Η συγκεκριμμένη κλάση έχει ως δεδομένα : 
• Stack<ScopeObject> mystack : η κεντρική στοίβα στην οποία προστίθενται τα αντικείμενα του προγράμματος σε κάθε εμβέλεια
• Map<Integer,Integer> map : καθορίζει τις εμβέλειες και την στοίβα κάθε εμβέλειας
• Stack<FuncScope> funcStack :	η στοίβα με τις συναρτήσεις του προγράμματος
• Map<String,List> refPar : το Dictionary που έχει ως κλειδί το όνομα της συνάρτησης και ως τιμή μία λίστα από τις παραμέτρους που είναι ref
• int position : η εμβέλεια κάθε στοίβας
• int ifWhileScope : τιμή που βλέπουμε που τελειώνουν τα if, while blocks για την σωστή καταμέτρηση των ετικετών κατά τις αναπηδήσεις


Για τον ενδιάμεσο κώδικα, δημιουργήσαμε την κλάση Intermediate.java η οποία έχει τις παρακάτω λειτουργίες (περιλαμβάνονται μόνο αυτές που χρησιμοποιούνται):

• Δημιουργία τετράδας με την συνάρτηση : genQuad
• Δημιουργία προσωρινής τιμής με την συνάρτηση : newTemp
• Εύρεση "καταχωρητή" φράσεις(expression) και επιστροφή του με την συνάρτηση : Place
• Εκτύπωση λίστας από τετράδες με την συνάρτηση : print
• Αλλαγή ετικέτας αναπήδησης μίας τετράδας από ένα συγκεκριμένο String σε συγκεκριμένο αριθμό με την συνάρτηση : backpatch
• Εισαγωγή "καταχωρητή" σε λίστα "καταχωρητών" με την συνάρτηση : insertReg
• Αλλαγή τετράδας "par, w , V, - " σε "par, w , RET, - " με την συνάρτηση : insertRet
• Αλλαγή τετράδας "par, w , V, - " σε "par, w , R, - " με την συνάρτηση : insertRef
• Εισαγωγή "ζευγαριού" (Expression,Position) στην βοηθητική λίστα για το Place με την συνάρτηση : insertPlaceHelper
• Εκτύπωση λίστας για την λίστα με τα Place με την συνάρτηση : printPlace

Η συγκεκριμμένη κλάση έχει ως δεδομένα : 
• int count : ο αριθμός των τετράδων
• List<Quad> quadList : η λίστα με τις τετράδες
• List<InterReg> regList :	η λίστα με τους "καταχωρητές"
• List<placeHelper> helpList : η λίστα με τα ζευγάρια -Έκφραση,"Καταχωρητής"- 
• OpCode opCode : ο τελεστής της τετράδας


Οι επιπλέον κλάσεις που χρησιμοποιήσαμε είναι οι εξής: 
• FuncScope : περιέχει πληροφορίες για τα functions που περιέχονται στο πρόγραμμα (όνομα, παράμετροι και οι τύποι τους, τύπος που επιστρέφει η συνάρτηση, αριθμός παραμέτρων)
• InterReg : περιέχει πληροφορίες για έναν καταχωρητή w (αριθμός ετικέτας, τελεστής που χρησιμοποιείται, τύπος δεδομένων, όνομα )
• MyException : κλάση που κληρονομεί από την κλάση Exception
• OpCode : περιλαμβάνει τους τελεστές
• operator : περιλαμβάνει όνομα τελεστή και τιμή για τους τελεστές "relop","op"
• Quad : περιέχει τον τελεστή και τα 3 arguments της τετράδας
• ScopeObject : περιέχει πληροφορίες για το Object της κύριας στοίβας του SymbolTable (όνομα , τύπο και τύπος μεταβλητής("var","par"...))
• placeHelper : περιέχει το expression και το position


Σχόλια

• Κατά την εκτέλεση των παραδειγμάτων, παρατηρήσαμε ότι το geti() σε μερικές περιπτώσεις καλείται με numeric parameter αλλά στην εκφώνηση, η δήλωσή της είναι χωρίς, οπότε και σχολιάσαμε το συγκεκριμένο κόμματι κώδικα.
• Κατά την κλήση μίας συνάρτησησης, δεν καταφέραμε να υλοποιήσουμε σωστά τον έλεγχο των τύπων των παραμέτρων.



Μεταγλώττιση της εργασίας

• Για τη μεταγλώττιση της εργασίας, χρησιμοποιήσαμε το εργαλείο maven που παρέχεται από το πρόγραμμα IntelliJ IDEA.
• Κάνουμε import,  από το φάκελο Skeleton.java,  το αρχείο pom.xml.
• Μεταγλωττίζουμε το πρόγραμμα με τις επιλογές clean (διαγραφή generated  αρχείων) και compile (build -> δημιουργία generated  αρχείων) του προγράμματος IntelliJ IDEA από το παράθυρο Maven Projects.


Εκτέλεση Αρχείου

• Επιλέγουμε την Main.java ως προεπιλεγμένη main του project μας.
• Για την εκτέλεση αρχείου απαιτείται η εισαγωγή κάποιου προγράμματος είτε με System.in είτε με ολοκληρωμένο path.

