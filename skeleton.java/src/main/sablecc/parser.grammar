Package compiler;


Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009;
    line_terminator = lf | cr | cr lf;
    white_space = (sp | ht | ff | line_terminator)*;
    white_space2 = (sp | ht | ff | cr)*;
    lowercase = ['a' .. 'z'];
    uppercase = ['A' .. 'Z'];
    number = ['0' .. '9']+;
    digit = ['0' .. '9'];


    letter = lowercase | uppercase;

    hex_prefix = 'x';
    hex_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
    hex_constant = hex_prefix hex_digit hex_digit;

    underscore='_';
    backslash = '\';
    mono_eisagwgiko = ''';
    diplo_eisagwgiko = '"';

    esc_ch_nl='\n';
    esc_ch_tab='\t';
    esc_ch_cr='\r';
    esc_ch0='\0';
    esc_ch_bs='\\';
    esc_ch_me= backslash mono_eisagwgiko;
    esc_ch_de='\"';
    esc_ch_asc=backslash hex_constant;

    esc_ch = esc_ch_nl | esc_ch_tab | esc_ch_cr | esc_ch0 | esc_ch_bs | esc_ch_me | esc_ch_de | esc_ch_asc;

    symbol_without_backslash = '!' | ':' | '@' | '$' | '%' | '^' | '&' | '*' | '.' | '(' | ')'|';'|'<'|'>'| ',' | '?' | '/' | '|' | '{' | '}' | '[' | ']' | '`' | '~' | esc_ch | sp;
    symbol = symbol_without_backslash | backslash;



    plus = '+';
    minus = '-';
    mult = '*';
    div = '/';
    equal = '=';
    not_equal = '#';
    greater = '>';
    smaller = '<';
    smaller_eq = '<=';
    greater_eq = '>=';

    l_par = '(';
    r_par = ')';
    l_br = '[';
    r_br = ']';
    curly_l_br = '{';
    curly_r_br = '}';
    comma = ',';
    semicolon = ';';
    colon = ':';
    assign = '<-';

    dollar = '$';
    double_dollar = '$$';
    all = [0 .. 0xffff];
    all_not_nl = [all - lf];
    all_not_dol = [all - dollar];
    all_not_dol_not_lf = [all_not_nl - dollar];

    comment_line = dollar all_not_dol_not_lf all_not_nl*;

    mul_comment_line = double_dollar all_not_dol* double_dollar;

    mod = 'mod';
    div1 = 'div';

Tokens
    and = 'and';
    char = 'char';
    div1 = div1;
    do = 'do';
    else = 'else';
    fun = 'fun';
    if = 'if';
    int = 'int';
    mod = mod;
    not = 'not';
    nothing = 'nothing';
    or = 'or';
    ref = 'ref';
    return = 'return';
    then = 'then';
    var = 'var';
    while = 'while';

    mod_space = sp mod sp;
    div_space = sp div1 sp;

    var_name = letter (letter | number |  underscore)*;
    constant = number*;


    constant_character = mono_eisagwgiko (esc_ch |letter |number | symbol) mono_eisagwgiko;

    constant_string = diplo_eisagwgiko (letter | number | esc_ch | symbol_without_backslash | white_space2)* diplo_eisagwgiko;


    white_space = white_space;
    comment_line = comment_line;
    mul_comment_line = mul_comment_line;

    array = ('int' | 'char') '[' ']' ('['  number ']')*
            | ('int' | 'char') ('['  number ']')*;

    another_type = 'another type';
    l_par = l_par;
    r_par = r_par;
    l_br = l_br;
    r_br = r_br;
    curly_l_br = curly_l_br;
    curly_r_br = curly_r_br;
    comma = comma;
    semicolon = semicolon;
    colon = colon;
    assign = assign;

    plus = plus;
    minus = minus;
    mult = mult;
    div = div;
    equal = equal;
    not_equal = not_equal;
    greater = greater;
    smaller = smaller;
    smaller_eq = smaller_eq;
    greater_eq = greater_eq;

Ignored Tokens
    white_space,
    comment_line,
    mul_comment_line;


Productions

    program = {func_def} func_def{->New program(func_def)};      /* func_def */

    func_def = {func_def} header local_def* block{->New func_def.all(New head_help(header.head_help, [local_def.head_help]),block.func_def)};     /*header local_def* block*/

    header{->func_def} = {with_header_helper_bigger} fun var_name l_par header_helper_bigger header_helper2 ret_type{->New func_def.header(New head(fun, var_name),ret_type.func_def)}
                | {without_header_helper_bigger} fun var_name l_par header_helper2 ret_type {->New func_def.header(New head(fun, var_name),ret_type.func_def)};    /* fun var_name ret_type*/

    header_helper{->func_def} = semicolon fpar_def{->fpar_def.func_def};
    header_helper_bigger{->func_def} = fpar_def header_helper*{->fpar_def.func_def};
    header_helper2 = r_par colon;

    fpar_def{->func_def} = {with_ref} ref var_name var_def_helper* colon_id fpar_type{->New func_def.fpar_def(New fpar(ref, var_name),fpar_type.func_def)}        /*ref var_name fpar_type */
               |{no_ref} var_name var_def_helper* colon_id fpar_type{->fpar_type.func_def};

    data_type{->func_def} = {int} int {->New data_type.int(int)}
    | {char} char {->New data_type.char(char)};

    type{->func_def} = {dt} data_type type_helper*{->data_type.func_def}  /*constant*/
            | {ar} array   {->New func_def.array(array)} ;          /* array */
    type_helper{->func_def} = l_br constant r_br {->New func_def.constant(constant)};

    ret_type{->func_def} = {dt} data_type {->data_type.func_def}
    | {nothing} nothing {->New func_def.nothing(nothing)} ;

    fpar_type{->func_def} = {dt_with_helper} data_type fpar_type_helper2 {->data_type.func_def}
                | {dt_without_helper} data_type {->data_type.func_def}
                | {arr} array {->New func_def.array(array)};

    brs = l_br r_br;
    fpar_type_helper = l_br constant r_br;
    fpar_type_helper2 = {with_brs} brs fpar_type_helper*
                        | {without_brs} fpar_type_helper*;


    local_def{->func_def} = {func_def} func_def {->func_def.func_def}
    | {func_decl} func_decl {->func_decl.func_def}
    | {var_def} var_def{->var_def.func_def};

    var_def{->func_def} = var var_name var_def_helper* colon_id type semicolon{->New func_def.var_def(New var1(var,var_name),type.func_def)};
    var_def_helper{->func_def} = comma var_name{->New func_def.var_help(var_name)};
    colon_id = colon;

    func_decl{->func_def} = header semicolon{->header.func_def};

    block = {block} curly_l_br curly_r_br;


Abstract Syntax Tree

    program = func_def;

    func_def = {all} head_help func_def
               | {header} [l]:head [r]:func_def
               | {fpar_def} [l]:fpar [r]:func_def
               | {data_type} func_def
               | {constant} constant
               | {nothing} nothing
               | {array} array
               | {var_def} var1 func_def
               | {var_help} var_name;

    data_type = {int} int
                | {char} char;


    head_help = [l]:head_help [r]:head_help*;
    head = fun var_name;
    fpar = ref var_name;
    var1 = var var_name;

