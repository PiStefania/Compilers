Package compiler;


Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009;
    line_terminator = lf | cr | cr lf;
    white_space = (sp | ht | ff | line_terminator)*;
    white_space2 = (sp | ht | ff | cr)*;
    lowercase = ['a' .. 'z'];
    uppercase = ['A' .. 'Z'];
    number = ['0' .. '9']+;
    digit = ['0' .. '9'];


    letter = lowercase | uppercase;

    hex_prefix = 'x';
    hex_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
    hex_constant = hex_prefix hex_digit hex_digit;

    underscore='_';
    backslash = '\';
    mono_eisagwgiko = ''';
    diplo_eisagwgiko = '"';

    esc_ch_nl='\n';
    esc_ch_tab='\t';
    esc_ch_cr='\r';
    esc_ch0='\0';
    esc_ch_bs='\\';
    esc_ch_me= backslash mono_eisagwgiko;
    esc_ch_de='\"';
    esc_ch_asc=backslash hex_constant;

    esc_ch = esc_ch_nl | esc_ch_tab | esc_ch_cr | esc_ch0 | esc_ch_bs | esc_ch_me | esc_ch_de | esc_ch_asc;

    symbol_without_backslash = '!' | ':' | '@' | '$' | '%' | '^' | '&' | '*' | '.' | '(' | ')'|';'|'<'|'>'| ',' | '?' | '/' | '|' | '{' | '}' | '[' | ']' | '`' | '~' | esc_ch | sp;
    symbol = symbol_without_backslash | backslash;



    plus = '+';
    minus = '-';
    mult = '*';
    div = '/';
    equal = '=';
    not_equal = '#';
    greater = '>';
    smaller = '<';
    smaller_eq = '<=';
    greater_eq = '>=';

    l_par = '(';
    r_par = ')';
    l_br = '[';
    r_br = ']';
    curly_l_br = '{';
    curly_r_br = '}';
    comma = ',';
    semicolon = ';';
    colon = ':';
    assign = '<-';

    dollar = '$';
    double_dollar = '$$';
    all = [0 .. 0xffff];
    all_not_nl = [all - lf];
    all_not_dol = [all - dollar];
    all_not_dol_not_lf = [all_not_nl - dollar];

    comment_line = dollar all_not_dol_not_lf all_not_nl*;

    mul_comment_line = double_dollar all_not_dol* double_dollar;

    mod = 'mod';
    div1 = 'div';

Tokens
    and = 'and';
    char = 'char';
    div1 = div1;
    do = 'do';
    else = 'else';
    fun = 'fun';
    if = 'if';
    int = 'int';
    mod = mod;
    not = 'not';
    nothing = 'nothing';
    or = 'or';
    ref = 'ref';
    return = 'return';
    then = 'then';
    var = 'var';
    while = 'while';

    mod_space = sp mod sp;
    div_space = sp div1 sp;

    var_name = letter (letter | number |  underscore)*;
    constant = number*;


    constant_character = mono_eisagwgiko (esc_ch |letter |number | symbol) mono_eisagwgiko;

    constant_string = diplo_eisagwgiko (letter | number | esc_ch | symbol_without_backslash | white_space2)* diplo_eisagwgiko;


    white_space = white_space;
    comment_line = comment_line;
    mul_comment_line = mul_comment_line;

    array = ('int' | 'char') '[' ']' ('['  number ']')*
            | ('int' | 'char') ('['  number ']')*;

    another_type = 'another type';
    l_par = l_par;
    r_par = r_par;
    l_br = l_br;
    r_br = r_br;
    curly_l_br = curly_l_br;
    curly_r_br = curly_r_br;
    comma = comma;
    semicolon = semicolon;
    colon = colon;
    assign = assign;

    plus = plus;
    minus = minus;
    mult = mult;
    div = div;
    equal = equal;
    not_equal = not_equal;
    greater = greater;
    smaller = smaller;
    smaller_eq = smaller_eq;
    greater_eq = greater_eq;

Ignored Tokens
    white_space,
    comment_line,
    mul_comment_line;


Productions

    program = {func_def} func_def {->New program(func_def)};      /* func_def */

    func_def =  header local_def* block{->New func_def.func_def_all(header,[local_def],block)};     /*header local_def* block*/

    header{->func_def} = {with_header_helper_bigger} fun var_name l_par header_helper_bigger header_helper2 ret_type
            | {without_header_helper_bigger} fun var_name l_par header_helper2 ret_type;    /* fun var_name ret_type*/

    header_helper{->func_def} = semicolon fpar_def;
    header_helper_bigger{->func_def} = fpar_def header_helper*;
    header_helper2{->func_def} = r_par colon;

    fpar_def{->func_def} = {with_ref} ref var_name var_def_helper* colon_id fpar_type       /*ref var_name fpar_type */
               |{no_ref} var_name var_def_helper* colon_id fpar_type;

    data_type{->func_def} = {int} int
    | {char} char;

    type{->func_def} = {dt} data_type type_helper*  /*constant*/
            | {ar} array;               /* array */
    type_helper{->func_def} = l_br constant r_br;

    ret_type{->func_def} = {dt} data_type
    | {nothing} nothing;

    fpar_type{->func_def} = {dt_with_helper} data_type fpar_type_helper2
                | {dt_without_helper} data_type
                | {arr} array;

    brs{->func_def} = l_br r_br;
    fpar_type_helper{->func_def} = l_br constant r_br;
    fpar_type_helper2{->func_def} = {with_brs} brs fpar_type_helper*
                        | {without_brs} fpar_type_helper*;


    local_def{->func_def} = {func_def} func_def
    | {func_decl} func_decl
    | {var_def} var_def;

    var_def{->func_def} = var var_name var_def_helper* colon_id type semicolon;
    var_def_helper{->func_def} = comma var_name;
    colon_id {->func_def}= colon;

    func_decl{->func_def} = header semicolon;

    block{->func_def} = {block} curly_l_br curly_r_br;


Abstract Syntax Tree

 program = func_def;

 func_def = {func_def_all} [l]:func_def [c]:func_def* [r]:func_def;


