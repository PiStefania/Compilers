Package compiler;


Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009;
    line_terminator = lf | cr | cr lf;
    white_space = (sp | ht | ff | line_terminator)*;
    white_space2 = (sp | ht | ff | cr)*;
    lowercase = ['a' .. 'z'];
    uppercase = ['A' .. 'Z'];
    number = ['0' .. '9']+;
    digit = ['0' .. '9'];


    letter = lowercase | uppercase;

    hex_prefix = 'x';
    hex_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
    hex_constant = hex_prefix hex_digit hex_digit;

    underscore='_';
    backslash = '\';
    mono_eisagwgiko = ''';
    diplo_eisagwgiko = '"';

    esc_ch_nl='\n';
    esc_ch_tab='\t';
    esc_ch_cr='\r';
    esc_ch0='\0';
    esc_ch_bs='\\';
    esc_ch_me= backslash mono_eisagwgiko;
    esc_ch_de='\"';
    esc_ch_asc=backslash hex_constant;

    esc_ch = esc_ch_nl | esc_ch_tab | esc_ch_cr | esc_ch0 | esc_ch_bs | esc_ch_me | esc_ch_de | esc_ch_asc;

    symbol_without_backslash = '!' | ':' | '@' | '$' | '%' | '^' | '&' | '*' | '.' | '(' | ')'|';'|'<'|'>'| ',' | '?' | '/' | '|' | '{' | '}' | '[' | ']' | '`' | '~' | esc_ch | sp;
    symbol = symbol_without_backslash | backslash;



    plus = '+';
    minus = '-';
    mult = '*';
    div = '/';
    equal = '=';
    not_equal = '#';
    greater = '>';
    smaller = '<';
    smaller_eq = '<=';
    greater_eq = '>=';

    l_par = '(';
    r_par = ')';
    l_br = '[';
    r_br = ']';
    curly_l_br = '{';
    curly_r_br = '}';
    comma = ',';
    semicolon = ';';
    colon = ':';
    assign = '<-';

    dollar = '$';
    double_dollar = '$$';
    all = [0 .. 0xffff];
    all_not_nl = [all - lf];
    all_not_dol = [all - dollar];
    all_not_dol_not_lf = [all_not_nl - dollar];

    comment_line = dollar all_not_dol_not_lf all_not_nl*;

    mul_comment_line = double_dollar all_not_dol* double_dollar;

    mod = 'mod';
    div1 = 'div';

Tokens
    and = 'and';
    char = 'char';
    div1 = div1;
    do = 'do';
    else = 'else';
    fun = 'fun';
    if = 'if';
    int = 'int';
    mod = mod;
    not = 'not';
    nothing = 'nothing';
    or = 'or';
    ref = 'ref';
    return = 'return';
    then = 'then';
    var = 'var';
    while = 'while';

    mod_space = sp mod sp;
    div_space = sp div1 sp;

    var_name = letter (letter | number |  underscore)*;
    constant = number*;


    constant_character = mono_eisagwgiko (esc_ch |letter |number | symbol) mono_eisagwgiko;

    constant_string = diplo_eisagwgiko (letter | number | esc_ch | symbol_without_backslash | white_space2)* diplo_eisagwgiko;


    white_space = white_space;
    comment_line = comment_line;
    mul_comment_line = mul_comment_line;

    array = ('int' | 'char') '[' ']' ('['  number ']')*
            | ('int' | 'char') ('['  number ']')*;

    another_type = 'another type';
    l_par = l_par;
    r_par = r_par;
    l_br = l_br;
    r_br = r_br;
    curly_l_br = curly_l_br;
    curly_r_br = curly_r_br;
    comma = comma;
    semicolon = semicolon;
    colon = colon;
    assign = assign;

    plus = plus;
    minus = minus;
    mult = mult;
    div = div;
    equal = equal;
    not_equal = not_equal;
    greater = greater;
    smaller = smaller;
    smaller_eq = smaller_eq;
    greater_eq = greater_eq;

Ignored Tokens
    white_space,
    comment_line,
    mul_comment_line;


Productions

    program = {func_def} func_def{->New program(func_def)};      /* func_def */

    func_def = {func_def} header local_def* block{->New func_def.all(New head_help.all(header.func_def, [local_def.func_def]),block.func_def)};     /*header local_def* block*/

    header{->func_def} = {with_header_helper_bigger} fun var_name l_par header_helper_bigger header_helper2 ret_type{->New func_def.header(New head(fun, var_name),ret_type.func_def)}
                | {without_header_helper_bigger} fun var_name l_par header_helper2 ret_type {->New func_def.header(New head(fun, var_name),ret_type.func_def)};    /* fun var_name ret_type*/

    header_helper{->func_def} = semicolon fpar_def{->fpar_def.func_def};
    header_helper_bigger{->func_def} = fpar_def header_helper*{->New func_def.header_big(fpar_def.func_def,[header_helper.func_def])};
    header_helper2 = r_par colon;

    fpar_def{->func_def} = {with_ref} ref var_name var_def_helper* colon_id fpar_type{->New func_def.fpar_def(New fpar(ref, var_name),fpar_type.func_def)}        /*ref var_name fpar_type */
               |{no_ref} var_name var_def_helper* colon_id fpar_type{->fpar_type.func_def};

    data_type{->func_def} = {int} int {->New func_def.int(int)}
    | {char} char {->New func_def.char(char)};

    type{->func_def} = {dt} data_type type_helper*{->data_type.func_def}  /*constant*/
            | {ar} array   {->New func_def.array(array)} ;          /* array */
    type_helper{->func_def} = l_br constant r_br {->New func_def.constant(constant)};

    ret_type{->func_def} = {dt} data_type {->data_type.func_def}
    | {nothing} nothing {->New func_def.nothing(nothing)} ;

    fpar_type{->func_def} = {dt_with_helper} data_type fpar_type_helper2 {->data_type.func_def}
                | {dt_without_helper} data_type {->data_type.func_def}
                | {arr} array {->New func_def.array(array)};

    brs = l_br r_br;
    fpar_type_helper = l_br constant r_br;
    fpar_type_helper2 = {with_brs} brs fpar_type_helper*
                        | {without_brs} fpar_type_helper*;


    local_def{->func_def} = {func_def} func_def {->func_def.func_def}
    | {func_decl} func_decl {->func_decl.func_def}
    | {var_def} var_def{->var_def.func_def};

    var_def{->func_def} = var var_name var_def_helper* colon_id type semicolon{->New func_def.var_def(New var1(var,var_name),type.func_def)};
    var_def_helper{->func_def} = comma var_name{->New func_def.var_help(var_name)};
    colon_id = colon;

    func_decl{->func_def} = header semicolon{->header.func_def};

    //block{->func_def} = {block} curly_l_br curly_r_br{->New func_def.block(curly_l_br,curly_r_br)};




    stmt = {semicolon} semicolon
              | {expression} l_value assign_id all_expr semicolon_id        //lvalue all_expr
              | {block} block                                               //block
              | {funcall} func_call semicolon_id                            //func_call
              | {if} if_stmt                                                //ifstmt
              | {while} while cond do_id stmt                               //while? cond stmt
              | {return_with_expr} return parentheses_expr semicolon_id     //return? parentheses_expr
              | {return_expr} return all_expr semicolon_id                  //return? all_expr
              | {return} return semicolon;                                  //return?




        if_stmt = {no_else} if cond then_id [then_stmt]:stmt                    // if? cond stmt
                  | {with_else} if cond then_id stmt_with_else else_id [else_stmt]:stmt;    //if? cond stmtelse stmt


        stmt_with_else = {semicolon} semicolon
                         | {expression} l_value assign_id all_expr semicolon_id  //lvalue all_expr
                         | {block} block                                         //block
                         | {funcall} func_call semicolon_id                        //func_call
                         | {if_else} if_else_stmt                               //ifelsestmt
                         | {while} while cond do_id stmt_with_else                         //while? cond stmtelse
                         | {return_with_expr} return parentheses_expr semicolon_id   //return? parentheses_expr
                         | {return_expr} return all_expr semicolon_id               //return? all_expr
                         | {return} return semicolon;                           //return?

        if_else_stmt = if cond then_id [then_stmt]:stmt_with_else else_id [else_stmt]:stmt_with_else;   //if? cpmd stmtwithelse stmtwithelse

        semicolon_id = semicolon;
        do_id = do;
        then_id = then;
        else_id = else;

        assign_id = assign;

        block = {block} curly_l_br stmt* curly_r_br;                         //stmt


        func_call = {with_par} var_name l_par parameters r_par                  //var_name parameters
                    | {without_par} var_name l_par r_par;                       //var_name

        parameters = {parameters} all_expr parameter*;                              //all_expr parameter*
        parameter = {parameter} comma all_expr;                                  //all_expr

        l_value = {var} var_name                                                //var_name
                  | {constant_string} constant_string                           //str
                  | {l_value} l_value lbr_id all_expr rbr_id;                       //lvaue all_expr

        lbr_id = l_br;
        rbr_id = r_br;




        all_expr = {exprcalc} expr_calc                                             //exprcalc
                   | {gen} general_expr;                                //general_expr


        general_expr =  {parexpr} parentheses_expr;                 //        parentheses_expr

        parentheses_expr =  {parexpr} l_par general_expr r_par;                 //general_expr


        expr_calc = {term} term                                     //term (no  new)
                    | {add_sub} expr_calc plus_minus term;              //expr_calc  term plus_minus2?

        term = {factor} factor                                      //factor( no new)
               | {rest_signs} term rest_signs factor;                   //term factor



        factor = {with_plmin} plus_minus2 factor                    //factor  plus_minus2?
                | {letter} constant_character                       //char
                | {l_value} l_value                                     //lvalue
                | {expr_calc} l_par expr_calc r_par                     //expr_calc
                | {fun} func_call                                   //func_call
                | {constant} constant;                              //constant



        plus_minus = {plus} plus | {minus} minus;
        plus_minus2 = {plus} plus | {minus} minus;

        rest_signs = {mult} mult | {div} div | {div1} div_space | {mod} mod_space;


        cond =  {cond_exp} cond_expr;                               //cond_expr



        ass_signs = {equal} equal
                    | {ne} not_equal
                    | {small} smaller
                    | {great} greater
                    | {smalle} smaller_eq
                    | {greate} greater_eq;

        cond_expr = {term_cond2} term_cond2                             //term_cond2 (no new)
                    | {or} cond_expr logical_or term_cond2;             //cond_expr  term_cond2

        term_cond2 = {term_cond1} term_cond1                            //term_cond1 (no new)
                     | {and} term_cond2 logical_and term_cond1;         //term_cond2  term_cond1

        term_cond1 = {factor_c} factor_cond                             //factor_cond (no new)
                    | {not} logical_not* factor_cond;                   //factor_cond

        logical_and = and;
        logical_or = or;
        logical_not = not;


        factor_cond = {as_cond} ass_cond                                            //ass_cond
                       | {par} l_par cond r_par;                                    //cond

        ass_cond =  {exprsigns} [before]:all_expr ass_signs [after]:all_expr;           //[before]:all_expr ass_signs [after]:all_expr


Abstract Syntax Tree

    program = func_def;

    func_def = {all} [l]: head_help [r]: func_def                          //done
               | {header} [l]:head [r]:func_def                            //done
               | {fpar_def} [l]:fpar [r]:func_def                          //done
               | {header_big} [l]:func_def [r]:func_def*
               | {int} int                                                 //done
               | {char} char                                               //done
               | {constant} constant                                       //done
               | {nothing} nothing                                         //done
               | {array} array                                             //done
               | {var_def} [l]: var1 [r]: func_def                         //done
               | {var_help} var_name                                       //done
               | {block} [l]: curly_l_br [r]:curly_r_br;                   //done

    head_help = {all} [l]:func_def [r]:func_def*;
    head = [l]:fun [r]:var_name;                                            //done
    fpar = [l]:ref [r]:var_name;                                            //done
    var1 = [l]:var [r]:var_name;                                            //done

